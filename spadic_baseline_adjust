#!/usr/bin/env python
# vim: syntax=python


PATH_TO_SPADIC_SW = '/home/cbm/cbmflib05/spadic10-sw/spadic'
PATH_TO_HITMONITOR = '/home/cbm/cbmflib05/spadic10-sw/lib/timeslice/demo'
FLIB_CTRL_BASE_PORT = 9750

import sys
sys.path.insert(0, PATH_TO_SPADIC_SW)
sys.path.insert(0, PATH_TO_HITMONITOR)
from walter_client import Spadic
from hitmonitor import HitMonitor


# TODO

def adjust_baselines(ctrl, monitor):
    res = ctrl.hitlogic.read()
    current_thresholds = [res['threshold1'], res['threshold2']]
    print "thresholds are now at", current_thresholds
    print "setting them to", thresholds
    ctrl.hitlogic.write(**dict(zip(['threshold1', 'threshold2'], thresholds)))

USAGE = """
usage: spadic_baseline_adjust <syscore #> <spadic #>
"""

SPADIC_BASE_ADDR = 0 # scv3 register 0x6a0
EQ_ID_BASE = 0xE000
ACQUIRE_INTERVAL = 0.1 # seconds to measure baseline + noise

    port = FLIB_CTRL_BASE_PORT + syscore_num
    host = 'tcp://localhost:%d' % port
    print 'setting thresholds of SPADIC #%d at %s...' % (spadic_num, host)
    s = Spadic(host, spadic_num)
    set_thresholds(s.ctrl, thresholds)
    print 'OK.'
class BaselineAdjuster:
    def __init__(self, argv):
        try:
            syscore_num, spadic_num = map(int, argv[1:3])
        except:
            raise SystemExit(USAGE)

        mon = {}
        for i in [0, 1]:
            eq_id = EQ_ID_BASE + syscore_num
            src_addr = SPADIC_BASE_ADDR + 2*spadic_num+i
            mon_arg = map(str, [eq_id, src_addr])
            mon[i] = HitMonitor(['dummy'] + mon_arg)
        self.mon = mon

        # Make a dummy reading to let the publisher know we are here.
        # Apparently we need to use the same time interval here as we use
        # later. If we use less, we will miss something later, if we use
        # more, we will get too much later.
        self.measure()

    def measure(self, interval=ACQUIRE_INTERVAL):
        rates = {}
        b_mean = {}
        b_std = {}
        for i in [0, 1]:
            res = self.mon[i].acquire(interval)
            for ch_str in sorted(res['baseline_mean']): # 'EEEE:LLLL:C'
                ch = int(ch_str[-1], 16) + 16 * i
                rates[ch] = res['hit_rates'][ch_str]
                b_mean[ch] = res['baseline_mean'][ch_str]
                b_std[ch] = res['baseline_std'][ch_str]
        return rates, b_mean, b_std


#---- MAIN -----------------------------------------------------------

def main(argv):
    adj = BaselineAdjuster(argv)
    r, m, s = adj.measure()
    print r
    print m
    print s

if __name__=='__main__':
    main(sys.argv)

#!/usr/bin/env python
# vim: syntax=python


PATH_TO_SPADIC_SW = '/home/cbm/cbmflib05/spadic10-sw/spadic'
PATH_TO_HITMONITOR = '/home/cbm/cbmflib05/spadic10-sw/lib/timeslice/demo'
FLIB_CTRL_BASE_PORT = 9750

import sys
sys.path.insert(0, PATH_TO_SPADIC_SW)
sys.path.insert(0, PATH_TO_HITMONITOR)
from walter_client import Spadic
from hitmonitor import HitMonitor


USAGE = """
usage: spadic_baseline_adjust <syscore #> <spadic #>
"""

SPADIC_BASE_ADDR = 0 # scv3 register 0x6a0
EQ_ID_BASE = 0xE000
ACQUIRE_INTERVAL = 1.0 # seconds to measure baseline + noise

class BaselineAdjuster:
    def __init__(self, argv):
        try:
            syscore_num, spadic_num = map(int, argv[1:3])
        except:
            raise SystemExit(USAGE)

        # set up HitMonitors
        mon = {}
        for i in [0, 1]:
            eq_id = EQ_ID_BASE + syscore_num
            src_addr = SPADIC_BASE_ADDR + 2*spadic_num+i
            mon_arg = map(str, [eq_id, src_addr])
            mon[i] = HitMonitor(['dummy'] + mon_arg)
        self.mon = mon

        # set up controls
        port = FLIB_CTRL_BASE_PORT + syscore_num
        host = 'tcp://localhost:%d' % port
        s = Spadic(host, spadic_num)
        self.ctrl = s.ctrl

        # set baseline settings to center values
        self.ctrl.update()
        for ch in range(32):
            self.set_setting(ch, 64)
        self.ctrl.apply()

        # Make a dummy reading to let the publisher know we are here.
        # Apparently we need to use the same time interval here as we use
        # later. If we use less, we will miss something later, if we use
        # more, we will get too much later.
        self.measure()

    def measure(self, interval=ACQUIRE_INTERVAL):
        res = {'rate': {}, 'mean': {}, 'std':  {}}
        for i in [0, 1]:
            a = self.mon[i].acquire(interval)
            for ch_str in sorted(a['baseline_mean']): # 'EEEE:LLLL:C'
                ch = int(ch_str[-1], 16) + 16 * i
                res['rate'][ch] = a['hit_rates'][ch_str]
                res['mean'][ch] = a['baseline_mean'][ch_str]
                res['std'][ch] = a['baseline_std'][ch_str]
        return res

    def get_setting(self, ch):
        return self.ctrl.frontend.channel[ch].get()['baseline']

    def set_setting(self, ch, value):
        self.ctrl.frontend.channel[ch].set(baseline=value)

    def adjust(self):
        self.ctrl.update()
        m = self.measure()
        old_baselines = {}
        old_settings = {}
        new_settings = {}

        # determine which channels are active
        channels = m['mean'].keys()
        print 'see data from channels', ' '.join(map(str, sorted(channels)))

        # TODO sort out broken channels (mean value off, noisy, ...)

        # determine slopes
        for ch in channels:
            old_baselines[ch] = m['mean'][ch]
            old_settings[ch] = self.get_setting(ch)
            new_settings[ch] = old_settings[ch] + 10
            self.set_setting(ch, new_settings[ch])
        self.ctrl.apply()
        m = self.measure()
        new_baselines = {ch: m['mean'][ch] for ch in channels}
        slopes = {ch: ((new_baselines[ch]-old_baselines[ch]) /
                       (new_settings[ch]-old_settings[ch]))
                  for ch in channels}

        for ch in channels:
            print ch, slopes[ch]

        # equalize baselines (target = median)
        target = sorted(new_baselines.values())[len(channels)/2]
        print old_baselines.values()
        print target
        for ch in channels:
            deviation = new_baselines[ch] - target
            correction = int(-deviation/slopes[ch])
            self.set_setting(ch, new_settings[ch] + correction - 10)

        self.ctrl.apply()


#---- MAIN -----------------------------------------------------------

def main(argv):
    adj = BaselineAdjuster(argv)
    adj.adjust()

if __name__=='__main__':
    main(sys.argv)
